// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const completeTask = `-- name: CompleteTask :one
UPDATE tasks
SET is_completed = TRUE, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

func (q *Queries) CompleteTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, completeTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (id, title, description, user_id) 
VALUES ($1, $2, $3, $4)
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

type CreateTaskParams struct {
	ID          uuid.UUID
	Title       string
	Description string
	UserID      uuid.UUID
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.UserID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const getAllTasks = `-- name: GetAllTasks :many
SELECT id, title, created_at, updated_at, deleted_at, user_id, description, is_completed FROM tasks WHERE deleted_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) GetAllTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getAllTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Description,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedTasksByUserId = `-- name: GetDeletedTasksByUserId :many
SELECT id, title, created_at, updated_at, deleted_at, user_id, description, is_completed FROM tasks WHERE user_id = $1 AND deleted_at IS NOT NULL ORDER BY updated_at DESC
`

func (q *Queries) GetDeletedTasksByUserId(ctx context.Context, userID uuid.UUID) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedTasksByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Description,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskById = `-- name: GetTaskById :one
SELECT id, title, created_at, updated_at, deleted_at, user_id, description, is_completed FROM tasks WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTaskById(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskById, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const getTasksByUserId = `-- name: GetTasksByUserId :many
SELECT id, title, created_at, updated_at, deleted_at, user_id, description, is_completed FROM tasks WHERE user_id = $1 AND deleted_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) GetTasksByUserId(ctx context.Context, userID uuid.UUID) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTasksByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Description,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const handleSearchTasks = `-- name: HandleSearchTasks :many
SELECT id, title, created_at, updated_at, deleted_at, user_id, description, is_completed FROM tasks
WHERE (title ILIKE '%' || $1 || '%')
AND ($2::int IS NULL OR user_id = $2)
AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT COALESCE(NULLIF($3, 0), 10) 
OFFSET COALESCE(NULLIF(($4 - 1) * COALESCE(NULLIF($3, 0), 10), -10), 0)
`

type HandleSearchTasksParams struct {
	Column1 sql.NullString
	Column2 int32
	Column3 interface{}
	Column4 interface{}
}

func (q *Queries) HandleSearchTasks(ctx context.Context, arg HandleSearchTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, handleSearchTasks,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Description,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteTask = `-- name: HardDeleteTask :one
DELETE FROM tasks
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

func (q *Queries) HardDeleteTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, hardDeleteTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const restoreTask = `-- name: RestoreTask :one
UPDATE tasks
SET deleted_at = NULL, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NOT NULL
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

func (q *Queries) RestoreTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, restoreTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const softDeleteTask = `-- name: SoftDeleteTask :one
UPDATE tasks
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

func (q *Queries) SoftDeleteTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, softDeleteTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const undoCompleteTask = `-- name: UndoCompleteTask :one
UPDATE tasks
SET is_completed = FALSE, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

func (q *Queries) UndoCompleteTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, undoCompleteTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}

const updateTaskPartial = `-- name: UpdateTaskPartial :one
UPDATE tasks
SET
  title = COALESCE(NULLIF($1, ''), title),
  description = COALESCE(NULLIF($2, ''), description),
  updated_at = NOW()
WHERE id = $3 AND deleted_at IS NULL
RETURNING id, title, created_at, updated_at, deleted_at, user_id, description, is_completed
`

type UpdateTaskPartialParams struct {
	Column1 interface{}
	Column2 interface{}
	ID      uuid.UUID
}

func (q *Queries) UpdateTaskPartial(ctx context.Context, arg UpdateTaskPartialParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTaskPartial, arg.Column1, arg.Column2, arg.ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Description,
		&i.IsCompleted,
	)
	return i, err
}
